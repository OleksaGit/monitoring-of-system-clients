Необходимо создать систему которая будет контролировать связь с большим кол-вом сетевых устройств (например 1,000,000 ).
Пусть скрипт "trni.js" будет одним из "устройств", связь с которыми нужно контролировать,
а скрипт "rcv.js" это ПО которое будет мониторить связь, а в случае ее отсутствия - сообщать об этом в консоль.

Задание:
1. Используя Node.js создать скрипт "trni.js" который будет  10 раз в минуту отправлять на сетевой слот (hostname = 'localhost', port = 2222) "ФИО" человека используя UDP протокол.
2. Создать скрипт "rcv.js", который будет "слушать" порт и сможет обнаружить что более одной минуты скрипт "trni.js" не работал.
3. В случае отсутствия связи с скриптом - вывести в консоль сообщение "нет связи с скриптом "trni.js""
4. Обеспечить поддержку одновременной работы нескольких скриптов  "trni.js" с различными "ФИО"

В результате выполнения задания вы должны передать нам два файла:  "trn1.js" и "rcv.js".
Проверяющая сторона может запустить несколько копий "trni.js" с различными именами. Со всеми этими копиями необходимо мониторить канал связи.

    Результат виконання завдання:
    Створено скрипт "trni.js в якому в змінну "nameControlPoint" передається імя контрольованої точки - прізвище імя по батькові.
Також задано порт, хост, та інтервал передачі.

    Створено скрипт "rcv.js" який приймає повідомлення по заданому хосту та порту.
Прийняті повідомлення записуються в память та перевіряються на втрату актуальності.
Коли втрачається звязок з скриптом "trni.js відповідний запис через визначений час втрачає актуальність, результатом є вивід в консоль повідомлення
типу "Нет связи с скриптом "trni.js - "імя контролюємої точки""

По техзавданню контролю загальної кількості пристроїв 1000000 було проведено дослідження, результат якого надано нижче.
Для контролю таких обємів інформації потрібно правильно спроектувати архітектуру серверної частини.
Це загальна структура побудови бекенду, один чи кілька фізичних серверів для розподілення навантаження, щоб не було втрати пакетів від великої щільності передачі.
    Також можна організувати кластера клієнтів UDP протоколу на одному фізичному сервері. Що для прикладу було реалізовано в "rcv-cluster.js".
В якому створюється кластера з обробниками UDP протоколу згідно кількості ядер процесора фізичного сервера на якому запускається скрипт.
Прийняті данні з кожного кластера формують єдиний обєкт в головному процесі, в якому й відбувається обчислення застарівання інформації та вивід контрольного повідомлення.
    В реальному використанні при таких обємах я б використав базу даних типу key:value - Redis, Memcached в яку напряму записували оброблені дані всі кластера чи фізичні сервери.
Перевага використання бази даних, в в можливості подальшого горизонтального маштабування кластерів чи фізичних серверів без порушення цілісності системи.
Контроль за застаріванням даних в даму випадку буде займатися головний процес в єдиній базі key:value.
Для контролю надійності рішення, потрібно слідкувати за навантаження кластерів чи фізичних серверів, щоб передбачити втрату пакетів при закінченні ресурсів сервера.
    Для тестового навантаження був створений скрипт "stress-test.js" в я кому є три різних види пакетної передачі по протоколі UDP.
    На практиці після 100000 запитів в мене закінчувалися ресурси ноутбука на якому велася розробка, падали копії скриптів стрес тесту.
Кластера на прийом працювали в нормі, але реальних замірів завантаженості я не робив.
Для реальної перевірки завантаження системи потрібно створити відповідну кільксть стрес тестів зважаючи на ресурси фізичного сервера який буде їх виконувати.

В загальному до побудови таких рішень потрібно враховувати багато факторів.
Скрипт "rcv-cluster.js" та "stress-test.js" були створені для прикладу можливої обробки даних і тестового навантаження готового рішення.

